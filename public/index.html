<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ’° Aurababy Market</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@800&display=swap" rel="stylesheet">
    
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
/* ===================================
   GLOBAL STYLES
   =================================== */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Poppins', sans-serif;
    font-weight: 800;
}

body {
    overflow-x: hidden;
    background: #f5f5f5;
}

/* ===================================
   AUTHENTICATION STYLES
   =================================== */
#auth-container {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: 20px;
}

#auth-box {
    background: white;
    padding: 40px;
    border-radius: 20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    max-width: 450px;
    width: 100%;
}

.auth-title {
    text-align: center;
    color: #667eea;
    margin-bottom: 10px;
    font-size: 32px;
}

.auth-subtitle-small {
    text-align: center;
    color: #999;
    margin-bottom: 20px;
    font-size: 14px;
    font-weight: 600;
}

.auth-subtitle {
    text-align: center;
    color: #666;
    margin-bottom: 20px;
    font-size: 18px;
}

.auth-input {
    width: 100%;
    padding: 15px;
    margin: 10px 0;
    border: 2px solid #ddd;
    border-radius: 10px;
    font-size: 16px;
    transition: border 0.3s;
}

.auth-input:focus {
    outline: none;
    border-color: #667eea;
}

.auth-button {
    width: 100%;
    padding: 15px;
    margin: 10px 0;
    border: none;
    border-radius: 10px;
    font-size: 18px;
    cursor: pointer;
    transition: all 0.3s;
    color: white;
}

.auth-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.auth-button:active {
    transform: translateY(0);
}

.primary-button {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.secondary-button {
    background: #95a5a6;
}

.guest-button {
    background: #34495e;
}

.error-message {
    color: #e74c3c;
    text-align: center;
    margin: 10px 0;
    font-size: 14px;
    font-weight: 600;
}

.success-message {
    color: #27ae60;
    text-align: center;
    margin: 10px 0;
    font-size: 14px;
    font-weight: 600;
}

/* ===================================
   LOADING SPINNER
   =================================== */
.loading {
    text-align: center;
    padding: 40px;
}

.loading-spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #667eea;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 20px auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* ===================================
   GAME CONTAINER
   =================================== */
#game-container {
    min-height: 100vh;
}

/* ===================================
   SIDEBAR
   =================================== */
.sidebar {
    width: 250px;
    min-height: 100vh;
    background: #2c3e50;
    color: white;
    padding: 20px;
    position: fixed;
    overflow-y: auto;
    z-index: 100;
}

.sidebar h2 {
    margin-bottom: 20px;
    font-size: 20px;
}

.sidebar-stats {
    margin-bottom: 30px;
    padding: 15px;
    background: #34495e;
    border-radius: 8px;
}

.sidebar-stats > div {
    margin-bottom: 10px;
    font-size: 14px;
}

.sidebar-stats strong {
    display: block;
    margin-bottom: 5px;
}

.sidebar-timer {
    font-size: 12px;
    color: #bdc3c7;
    padding-top: 10px;
    border-top: 1px solid #7f8c8d;
    margin-top: 10px;
}

.nav-button {
    width: 100%;
    padding: 12px;
    margin-bottom: 10px;
    background: #34495e;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    font-family: 'Poppins', sans-serif;
    font-weight: 800;
    transition: all 0.2s;
}

.nav-button:hover {
    background: #2980b9;
    transform: translateX(5px);
}

.nav-button.active {
    background: #3498db;
}

.logout-button {
    background: #e74c3c;
    margin-top: 20px;
}

.logout-button:hover {
    background: #c0392b;
}

.sidebar-footer {
    font-size: 10px;
    color: #95a5a6;
    margin-top: 20px;
    text-align: center;
    font-weight: 600;
}

/* ===================================
   MAIN CONTENT
   =================================== */
.main-content {
    margin-left: 250px;
    padding: 20px;
    width: calc(100% - 250px);
}

.view-title {
    font-size: 32px;
    margin-bottom: 20px;
    color: #2c3e50;
}

.view-subtitle {
    font-size: 16px;
    color: #7f8c8d;
    margin-bottom: 20px;
    font-weight: 600;
}

/* ===================================
   CARDS & GRID
   =================================== */
.card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.card {
    border: 2px solid #ddd;
    border-radius: 10px;
    padding: 15px;
    background: white;
    cursor: pointer;
    transition: all 0.2s;
}

.card:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.card img {
    width: 100%;
    height: 150px;
    object-fit: cover;
    border-radius: 8px;
}

.card h3 {
    margin: 10px 0;
    font-size: 18px;
    color: #2c3e50;
}

.card-price {
    font-size: 24px;
    font-weight: 800;
    margin: 10px 0;
}

.card-info {
    font-size: 14px;
    color: #7f8c8d;
    margin: 5px 0;
}

.card-button {
    width: 100%;
    padding: 12px;
    margin-top: 10px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s;
}

.buy-button {
    background: #27ae60;
    color: white;
}

.buy-button:hover {
    background: #229954;
}

.buy-button:disabled {
    background: #bdc3c7;
    cursor: not-allowed;
}

.sell-button {
    background: #e74c3c;
    color: white;
}

.sell-button:hover {
    background: #c0392b;
}

/* ===================================
   PROJECTED BABIES
   =================================== */
.projected-banner {
    background: linear-gradient(135deg, #f39c12 0%, #e74c3c 100%);
    padding: 15px;
    border-radius: 10px;
    color: white;
    margin: 15px 0;
    text-align: center;
}

.projected-card {
    border: 3px solid #e74c3c !important;
    background: linear-gradient(135deg, #ffe6e6 0%, #ffcccc 100%) !important;
    box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4) !important;
}

.projected-badge {
    position: absolute;
    top: 5px;
    right: 5px;
    background: #e74c3c;
    color: white;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 10px;
    z-index: 10;
}

.projected-timer {
    font-size: 11px;
    color: #e74c3c;
    margin-top: 5px;
}

/* ===================================
   LIMITED ITEMS
   =================================== */
.limited-card {
    border: 3px solid gold;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    position: relative;
}

.limited-emoji {
    font-size: 80px;
    text-align: center;
    margin-bottom: 10px;
}

.limited-tier-badge {
    position: absolute;
    top: 10px;
    right: 10px;
    background: gold;
    color: black;
    padding: 5px 10px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 800;
}

.limited-info {
    background: rgba(0,0,0,0.3);
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
}

.limited-serial {
    background: rgba(255,215,0,0.2);
    padding: 10px;
    border-radius: 8px;
    text-align: center;
    margin: 10px 0;
    border: 2px dashed gold;
}

/* ===================================
   TABS
   =================================== */
.tabs {
    display: flex;
    gap: 10px;
    margin: 20px 0;
    flex-wrap: wrap;
}

.tab-button {
    padding: 10px 20px;
    background: #95a5a6;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 800;
    transition: all 0.2s;
}

.tab-button:hover {
    background: #7f8c8d;
}

.tab-button.active {
    background: #3498db;
}

/* ===================================
   TRADE HISTORY
   =================================== */
.trade-item {
    padding: 15px;
    margin-bottom: 10px;
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.trade-buy {
    background: #cce5ff;
    border: 2px solid #007bff;
}

.trade-sell {
    background: #d4edda;
    border: 2px solid #28a745;
}

.trade-info {
    flex: 1;
}

.trade-price {
    font-size: 20px;
    font-weight: 800;
    text-align: right;
}

/* ===================================
   PROFILE
   =================================== */
.profile-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: 30px;
    border-radius: 15px;
    color: white;
    margin-bottom: 30px;
    text-align: center;
}

.profile-avatar {
    font-size: 60px;
    margin-bottom: 10px;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

.stat-card {
    padding: 20px;
    border-radius: 10px;
    color: white;
}

.stat-card-blue { background: #3498db; }
.stat-card-green { background: #27ae60; }
.stat-card-purple { background: #9b59b6; }
.stat-card-orange { background: #f39c12; }
.stat-card-red { background: #e74c3c; }
.stat-card-teal { background: #1abc9c; }
.stat-card-dark { background: #34495e; }

.stat-label {
    font-size: 14px;
    opacity: 0.9;
    margin-bottom: 10px;
}

.stat-value {
    font-size: 32px;
    font-weight: 800;
}

/* ===================================
   ACHIEVEMENTS
   =================================== */
.achievement-card {
    background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    padding: 15px;
    border-radius: 10px;
    color: white;
    display: flex;
    align-items: center;
    gap: 15px;
}

.achievement-icon {
    font-size: 30px;
}

.achievement-info h4 {
    margin-bottom: 5px;
}

.achievement-desc {
    font-size: 12px;
    opacity: 0.9;
    font-weight: 600;
}

/* ===================================
   LEADERBOARD
   =================================== */
.leaderboard-table {
    width: 100%;
    background: white;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.leaderboard-table table {
    width: 100%;
    border-collapse: collapse;
}

.leaderboard-table th {
    background: #3498db;
    color: white;
    padding: 15px;
    text-align: left;
    font-size: 16px;
}

.leaderboard-table td {
    padding: 12px 15px;
    border-bottom: 1px solid #ecf0f1;
}

.leaderboard-table tr:hover {
    background: #f8f9fa;
}

.leaderboard-rank {
    font-size: 20px;
    font-weight: 800;
    color: #3498db;
}

.leaderboard-highlight {
    background: #fff3cd !important;
    border-left: 4px solid #f39c12;
}

/* ===================================
   TRADE HUB
   =================================== */
.trade-ad-card {
    background: white;
    border: 2px solid #3498db;
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 15px;
}

.trade-ad-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.trade-ad-type {
    padding: 5px 15px;
    border-radius: 20px;
    font-size: 12px;
    color: white;
}

.trade-type-upgrade { background: #27ae60; }
.trade-type-downgrade { background: #e74c3c; }
.trade-type-lf { background: #9b59b6; }
.trade-type-selling { background: #f39c12; }

.trade-ad-content {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 8px;
    margin: 10px 0;
}

.trade-ad-actions {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.post-trade-form {
    background: white;
    padding: 25px;
    border-radius: 10px;
    margin-bottom: 30px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.form-group {
    margin-bottom: 20px;
}

.form-label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    color: #2c3e50;
}

.form-input,
.form-select,
.form-textarea {
    width: 100%;
    padding: 12px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 14px;
    font-family: 'Poppins', sans-serif;
    font-weight: 600;
}

.form-textarea {
    min-height: 100px;
    resize: vertical;
}

.form-button {
    padding: 12px 30px;
    background: #3498db;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 800;
    transition: all 0.2s;
}

.form-button:hover {
    background: #2980b9;
}

/* ===================================
   MODAL
   =================================== */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal {
    background: white;
    padding: 30px;
    border-radius: 15px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.modal h2 {
    margin-bottom: 20px;
    color: #2c3e50;
}

.modal-buttons {
    display: flex;
    gap: 10px;
    margin-top: 20px;
}

.modal-button {
    flex: 1;
    padding: 15px;
    border: none;
    border-radius: 8px;
    font-size: 18px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s;
}

.modal-button-primary {
    background: #27ae60;
    color: white;
}

.modal-button-secondary {
    background: #e74c3c;
    color: white;
}

.modal-button-cancel {
    background: #95a5a6;
    color: white;
}

/* ===================================
   NOTIFICATIONS
   =================================== */
.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    z-index: 2000;
    min-width: 300px;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.notification-success {
    border-left: 5px solid #27ae60;
}

.notification-error {
    border-left: 5px solid #e74c3c;
}

.notification-info {
    border-left: 5px solid #3498db;
}

/* ===================================
   RESPONSIVE
   =================================== */
@media (max-width: 768px) {
    .sidebar {
        width: 100%;
        position: relative;
        min-height: auto;
    }
    
    .main-content {
        margin-left: 0;
        width: 100%;
    }
    
    .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    }
    
    .stats-grid {
        grid-template-columns: 1fr;
    }
}

/* ===================================
   UTILITY CLASSES
   =================================== */
.text-center { text-align: center; }
.text-right { text-align: right; }
.text-success { color: #27ae60; }
.text-danger { color: #e74c3c; }
.text-warning { color: #f39c12; }
.text-info { color: #3498db; }
.text-muted { color: #7f8c8d; }

.mt-10 { margin-top: 10px; }
.mt-20 { margin-top: 20px; }
.mt-30 { margin-top: 30px; }
.mb-10 { margin-bottom: 10px; }
.mb-20 { margin-bottom: 20px; }
.mb-30 { margin-bottom: 30px; }

.flex { display: flex; }
.flex-center { display: flex; justify-content: center; align-items: center; }
.flex-between { display: flex; justify-content: space-between; align-items: center; }
.flex-gap-10 { gap: 10px; }
.flex-gap-20 { gap: 20px; }
    </style>
</head>
<body>
    <div id="auth-container">
        <div id="auth-box">
            <h1 class="auth-title">ðŸ’° Aurababy Market</h1>
            <p class="auth-subtitle-small">Multiplayer Trading Game</p>
            
            <div id="login-form">
                <h3 class="auth-subtitle">Welcome Back!</h3>
                <div id="login-error" class="error-message" style="display:none;"></div>
                <input type="text" id="login-username" class="auth-input" placeholder="Username">
                <input type="password" id="login-password" class="auth-input" placeholder="Password">
                <button onclick="loginUser()" class="auth-button primary-button">Login</button>
                <button onclick="showSignup()" class="auth-button secondary-button">Create Account</button>
                <button onclick="loginAnonymous()" class="auth-button guest-button">Play as Guest</button>
            </div>
            
            <div id="signup-form" style="display: none;">
                <h3 class="auth-subtitle">Create Your Account</h3>
                <div id="signup-error" class="error-message" style="display:none;"></div>
                <input type="text" id="signup-username" class="auth-input" placeholder="Username (3-20 characters)">
                <input type="password" id="signup-password" class="auth-input" placeholder="Password (min 6 characters)">
                <input type="password" id="signup-confirm" class="auth-input" placeholder="Confirm Password">
                <button onclick="signupUser()" class="auth-button primary-button">Create Account</button>
                <button onclick="showLogin()" class="auth-button secondary-button">Back to Login</button>
            </div>
            
            <div id="loading-screen" style="display: none;">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <h3>Loading your game...</h3>
                </div>
            </div>
        </div>
    </div>

    <div id="game-container" style="display: none;">
        <div id="root"></div>
    </div>

    <script>
    // Firebase Config
    const firebaseConfig = {
        apiKey: "AIzaSyBUXT3jdC1miTjbyG5dcuRdd8oSqzT4OMo",
        authDomain: "aurababymarket.firebaseapp.com",
        projectId: "aurababymarket",
        storageBucket: "aurababymarket.firebasestorage.app",
        messagingSenderId: "335246667462",
        appId: "1:335246667462:web:3b39c5bc78e05a674971c7",
        measurementId: "G-KSFT7RBPL3"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    let currentUserAuth = null; // Changed variable name to avoid conflicts
    console.log('Firebase initialized successfully!');
// ===================================
// AUTHENTICATION LOGIC
// ===================================

let currentUserAuth = null;
let userDocRef = null;
let gameStateLoaded = false;

// Global game state for Firebase saving
window.gameState = {
    username: 'Trader',
    money: 1000,
    portfolio: {},
    limitedInventory: {},
    limitedMintCounts: {},
    tradeHistory: [],
    highestMoney: 1000,
    highestNetWorth: 1000,
    createdAt: null
};

// ===================================
// AUTH UI FUNCTIONS
// ===================================

function showLogin() {
    document.getElementById('login-form').style.display = 'block';
    document.getElementById('signup-form').style.display = 'none';
    document.getElementById('login-error').style.display = 'none';
    document.getElementById('signup-error').style.display = 'none';
}

function showSignup() {
    document.getElementById('login-form').style.display = 'none';
    document.getElementById('signup-form').style.display = 'block';
    document.getElementById('login-error').style.display = 'none';
    document.getElementById('signup-error').style.display = 'none';
}

// ===================================
// LOGIN
// ===================================

async function loginUser() {
    const username = document.getElementById('login-username').value.trim().toLowerCase();
    const password = document.getElementById('login-password').value;
    const errorDiv = document.getElementById('login-error');
    
    if (!username || !password) {
        errorDiv.textContent = 'Please enter username and password';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (username.length < 3 || username.length > 20) {
        errorDiv.textContent = 'Username must be 3-20 characters';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (!/^[a-z0-9_]+$/.test(username)) {
        errorDiv.textContent = 'Username can only contain letters, numbers, and underscores';
        errorDiv.style.display = 'block';
        return;
    }
    
    try {
        errorDiv.style.display = 'none';
        const email = username + '@aurababymarket.app';
        await auth.signInWithEmailAndPassword(email, password);
    } catch (error) {
        if (error.code === 'auth/user-not-found') {
            errorDiv.textContent = 'Username not found. Please sign up first.';
        } else if (error.code === 'auth/wrong-password') {
            errorDiv.textContent = 'Incorrect password';
        } else {
            errorDiv.textContent = 'Login failed. Please try again.';
        }
        errorDiv.style.display = 'block';
    }
}

// ===================================
// SIGNUP
// ===================================

async function signupUser() {
    const username = document.getElementById('signup-username').value.trim().toLowerCase();
    const password = document.getElementById('signup-password').value;
    const confirmPassword = document.getElementById('signup-confirm').value;
    const errorDiv = document.getElementById('signup-error');
    
    if (!username) {
        errorDiv.textContent = 'Please enter a username';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (username.length < 3 || username.length > 20) {
        errorDiv.textContent = 'Username must be 3-20 characters';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (!/^[a-z0-9_]+$/.test(username)) {
        errorDiv.textContent = 'Username can only contain letters, numbers, and underscores';
        errorDiv.style.display = 'block';
        return;
    }
    
    const reserved = ['admin', 'moderator', 'system', 'guest', 'official', 'support'];
    if (reserved.includes(username)) {
        errorDiv.textContent = 'This username is reserved';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (!password) {
        errorDiv.textContent = 'Please enter a password';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (password.length < 6) {
        errorDiv.textContent = 'Password must be at least 6 characters';
        errorDiv.style.display = 'block';
        return;
    }
    
    if (password !== confirmPassword) {
        errorDiv.textContent = 'Passwords do not match';
        errorDiv.style.display = 'block';
        return;
    }
    
    try {
        errorDiv.style.display = 'none';
        
        const email = username + '@aurababymarket.app';
        
        // Check if username exists
        const usernameDoc = await db.collection('usernames').doc(username).get();
        if (usernameDoc.exists) {
            errorDiv.textContent = 'Username already taken. Please choose another.';
            errorDiv.style.display = 'block';
            return;
        }
        
        // Create account
        const result = await auth.createUserWithEmailAndPassword(email, password);
        
        // Store username mapping
        await db.collection('usernames').doc(username).set({
            uid: result.user.uid,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        // Create initial user document
        await db.collection('users').doc(result.user.uid).set({
            username: username,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
    } catch (error) {
        if (error.code === 'auth/email-already-in-use') {
            errorDiv.textContent = 'Username already taken. Please choose another.';
        } else if (error.code === 'auth/weak-password') {
            errorDiv.textContent = 'Password is too weak. Use at least 6 characters.';
        } else {
            errorDiv.textContent = 'Signup failed: ' + error.message;
        }
        errorDiv.style.display = 'block';
    }
}

// ===================================
// ANONYMOUS LOGIN
// ===================================

async function loginAnonymous() {
    const errorDiv = document.getElementById('login-error');
    try {
        errorDiv.style.display = 'none';
        await auth.signInAnonymously();
    } catch (error) {
        errorDiv.textContent = 'Guest login failed. Please try again.';
        errorDiv.style.display = 'block';
    }
}

// ===================================
// LOGOUT
// ===================================

async function logoutUser() {
    if (confirm('Are you sure you want to logout? Your progress is saved automatically.')) {
        await saveGameData();
        await auth.signOut();
    }
}

// ===================================
// AUTH STATE OBSERVER
// ===================================

auth.onAuthStateChanged(async (user) => {
    if (user) {
        currentUserAuth = user;
        userDocRef = db.collection('users').doc(user.uid);
        
        // Show loading
        document.getElementById('login-form').style.display = 'none';
        document.getElementById('signup-form').style.display = 'none';
        document.getElementById('loading-screen').style.display = 'block';
        
        // Load game data
        await loadGameData();
        
        // Hide auth, show game
        document.getElementById('auth-container').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        
        // Initialize game (React will mount)
        if (!gameStateLoaded) {
            gameStateLoaded = true;
        }
    } else {
        currentUserAuth = null;
        userDocRef = null;
        gameStateLoaded = false;
        document.getElementById('auth-container').style.display = 'flex';
        document.getElementById('game-container').style.display = 'none';
        showLogin();
    }
});

// ===================================
// SAVE/LOAD FUNCTIONS
// ===================================

async function loadGameData() {
    if (!userDocRef) return;
    
    try {
        const doc = await userDocRef.get();
        if (doc.exists) {
            const data = doc.data();
            window.gameState = {
                username: data.username || (currentUserAuth.isAnonymous ? 'Guest' : 'Trader'),
                money: data.money !== undefined ? data.money : 1000,
                portfolio: data.portfolio || {},
                limitedInventory: data.limitedInventory || {},
                limitedMintCounts: data.limitedMintCounts || {},
                tradeHistory: data.tradeHistory || [],
                highestMoney: data.highestMoney || 1000,
                highestNetWorth: data.highestNetWorth || 1000,
                createdAt: data.createdAt || null
            };
            console.log('Game data loaded!', window.gameState);
        } else {
            // New user - create initial document
            const username = currentUserAuth.isAnonymous ? 'Guest' : 'Trader';
            window.gameState = {
                username: username,
                money: 1000,
                portfolio: {},
                limitedInventory: {},
                limitedMintCounts: {},
                tradeHistory: [],
                highestMoney: 1000,
                highestNetWorth: 1000,
                createdAt: new Date()
            };
            await saveGameData();
        }
    } catch (error) {
        console.error('Load failed:', error);
    }
}

async function saveGameData() {
    if (!userDocRef || !window.gameState) return;
    
    try {
        await userDocRef.set({
            username: window.gameState.username,
            money: window.gameState.money,
            portfolio: window.gameState.portfolio,
            limitedInventory: window.gameState.limitedInventory,
            limitedMintCounts: window.gameState.limitedMintCounts,
            tradeHistory: window.gameState.tradeHistory,
            highestMoney: window.gameState.highestMoney,
            highestNetWorth: window.gameState.highestNetWorth,
            createdAt: window.gameState.createdAt || firebase.firestore.FieldValue.serverTimestamp(),
            lastSaved: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
        
        console.log('Game saved!');
    } catch (error) {
        console.error('Save failed:', error);
    }
}

// Auto-save every 30 seconds
setInterval(() => {
    if (currentUser && window.gameState) {
        saveGameData();
    }
}, 30000);

// Save before closing
window.addEventListener('beforeunload', () => {
    if (currentUser && window.gameState) {
        saveGameData();
    }
});
    </script>

    <script>
    // Multiplayer Module (Fixed variable names)
    let multiplayerCurrentUser = null;
// MULTIPLAYER FEATURES
// Global Leaderboard, Trade Hub, Player Trading
// ===================================

// ===================================
// LEADERBOARD SYSTEM
// ===================================

/**
 * Update the leaderboard with current player stats
 * Call this whenever the player makes a trade
 */
async function updateLeaderboard(playerData) {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return;
    }
    
    try {
        const netWorth = playerData.money + playerData.portfolioValue;
        const totalBabies = Object.values(playerData.portfolio).reduce((sum, qty) => sum + qty, 0);
        const totalLimiteds = Object.values(playerData.limitedInventory).reduce((sum, arr) => sum + arr.length, 0);
        
        await db.collection('leaderboard').doc(multiplayerCurrentUser.uid).set({
            username: playerData.username,
            netWorth: netWorth,
            money: playerData.money,
            portfolioValue: playerData.portfolioValue,
            totalTrades: playerData.tradeHistory.length,
            babiesOwned: totalBabies,
            limitedsOwned: totalLimiteds,
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        console.log('Leaderboard updated!');
    } catch (error) {
        console.error('Leaderboard update failed:', error);
    }
}

/**
 * Load top 10 players from leaderboard
 * @returns {Array} Array of top 10 players
 */
async function loadLeaderboard() {
    if (!db) {
        console.error('DB not initialized');
        return [];
    }
    
    try {
        const snapshot = await db.collection('leaderboard')
            .orderBy('netWorth', 'desc')
            .limit(10)
            .get();
        
        const leaders = [];
        snapshot.forEach(doc => {
            leaders.push({ 
                id: doc.id, 
                ...doc.data(),
                isCurrentUser: multiplayerCurrentUser && doc.id === multiplayerCurrentUser.uid
            });
        });
        
        console.log('Leaderboard loaded:', leaders.length, 'players');
        return leaders;
    } catch (error) {
        console.error('Load leaderboard failed:', error);
        return [];
    }
}

/**
 * Get current player's rank
 * @returns {Object} {rank, totalPlayers}
 */
async function getMyRank() {
    if (!multiplayerCurrentUser || !db) return null;
    
    try {
        const myDoc = await db.collection('leaderboard').doc(multiplayerCurrentUser.uid).get();
        if (!myDoc.exists) return null;
        
        const myNetWorth = myDoc.data().netWorth;
        
        const higherRanked = await db.collection('leaderboard')
            .where('netWorth', '>', myNetWorth)
            .get();
        
        const totalPlayers = await db.collection('leaderboard').get();
        
        return {
            rank: higherRanked.size + 1,
            totalPlayers: totalPlayers.size
        };
    } catch (error) {
        console.error('Get rank failed:', error);
        return null;
    }
}

// ===================================
// GLOBAL PRICE SYNC
// ===================================

/**
 * Save current prices to Firebase (for all players to see)
 * Call this every 30 minutes when prices update
 */
async function saveGlobalPrices(pricesData) {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return;
    }
    
    try {
        await db.collection('globalPrices').doc('current').set({
            babyPrices: pricesData.babyPrices,
            limitedValues: pricesData.limitedValues,
            projectedBabies: pricesData.projectedBabies || [],
            lastUpdate: firebase.firestore.FieldValue.serverTimestamp(),
            updatedBy: multiplayerCurrentUser.uid
        });
        
        console.log('Global prices saved!');
        return true;
    } catch (error) {
        console.error('Save global prices failed:', error);
        return false;
    }
}

/**
 * Load global prices from Firebase
 * @returns {Object} {babyPrices, limitedValues, projectedBabies}
 */
async function loadGlobalPrices() {
    if (!db) {
        console.error('DB not initialized');
        return null;
    }
    
    try {
        const priceDoc = await db.collection('globalPrices').doc('current').get();
        
        if (priceDoc.exists) {
            const data = priceDoc.data();
            console.log('Global prices loaded!');
            return {
                babyPrices: data.babyPrices || {},
                limitedValues: data.limitedValues || {},
                projectedBabies: data.projectedBabies || [],
                lastUpdate: data.lastUpdate
            };
        } else {
            console.log('No global prices found - will initialize');
            return null;
        }
    } catch (error) {
        console.error('Load global prices failed:', error);
        return null;
    }
}

/**
 * Listen to real-time price updates
 * @param {Function} callback - Called when prices change
 * @returns {Function} Unsubscribe function
 */
function listenToGlobalPrices(callback) {
    if (!db) {
        console.error('DB not initialized');
        return () => {};
    }
    
    const unsubscribe = db.collection('globalPrices').doc('current')
        .onSnapshot((doc) => {
            if (doc.exists) {
                const data = doc.data();
                console.log('Real-time price update received!');
                callback({
                    babyPrices: data.babyPrices || {},
                    limitedValues: data.limitedValues || {},
                    projectedBabies: data.projectedBabies || []
                });
            }
        }, (error) => {
            console.error('Price listener error:', error);
        });
    
    return unsubscribe;
}

// ===================================
// TRADE ADS SYSTEM
// ===================================

/**
 * Post a new trade ad
 * @param {Object} adData - Trade ad details
 * @returns {String} Ad ID
 */
async function postTradeAd(adData) {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return null;
    }
    
    try {
        const ad = {
            userId: multiplayerCurrentUser.uid,
            username: adData.username,
            type: adData.type, // 'upgrade', 'downgrade', 'lf', 'selling'
            offering: adData.offering || {
                items: [], // Array of limited item IDs
                babies: {}, // {babyId: quantity}
                cash: 0
            },
            lookingFor: adData.lookingFor || {
                items: [],
                babies: {},
                cash: 0,
                description: '' // e.g., "Any 5 legendaries"
            },
            description: adData.description || '',
            status: 'active',
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            expiresAt: firebase.firestore.Timestamp.fromDate(
                new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
            )
        };
        
        const docRef = await db.collection('tradeAds').add(ad);
        console.log('Trade ad posted!', docRef.id);
        return docRef.id;
    } catch (error) {
        console.error('Post trade ad failed:', error);
        return null;
    }
}

/**
 * Load all active trade ads
 * @param {String} filterType - Filter by ad type (optional)
 * @returns {Array} Array of trade ads
 */
async function loadTradeAds(filterType = null) {
    if (!db) {
        console.error('DB not initialized');
        return [];
    }
    
    try {
        let query = db.collection('tradeAds')
            .where('status', '==', 'active')
            .orderBy('createdAt', 'desc')
            .limit(50);
        
        if (filterType) {
            query = query.where('type', '==', filterType);
        }
        
        const snapshot = await query.get();
        
        const ads = [];
        snapshot.forEach(doc => {
            ads.push({ 
                id: doc.id, 
                ...doc.data(),
                isMyAd: multiplayerCurrentUser && doc.data().userId === multiplayerCurrentUser.uid
            });
        });
        
        console.log('Trade ads loaded:', ads.length);
        return ads;
    } catch (error) {
        console.error('Load trade ads failed:', error);
        return [];
    }
}

/**
 * Delete a trade ad (only your own)
 * @param {String} adId - Ad ID to delete
 */
async function deleteTradeAd(adId) {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return false;
    }
    
    try {
        const adDoc = await db.collection('tradeAds').doc(adId).get();
        
        if (!adDoc.exists) {
            console.error('Ad not found');
            return false;
        }
        
        if (adDoc.data().userId !== multiplayerCurrentUser.uid) {
            console.error('Cannot delete another users ad');
            return false;
        }
        
        await db.collection('tradeAds').doc(adId).update({
            status: 'cancelled',
            cancelledAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        console.log('Trade ad deleted!');
        return true;
    } catch (error) {
        console.error('Delete trade ad failed:', error);
        return false;
    }
}

/**
 * Listen to real-time trade ads
 * @param {Function} callback - Called when ads change
 * @returns {Function} Unsubscribe function
 */
function listenToTradeAds(callback) {
    if (!db) {
        console.error('DB not initialized');
        return () => {};
    }
    
    const unsubscribe = db.collection('tradeAds')
        .where('status', '==', 'active')
        .orderBy('createdAt', 'desc')
        .limit(50)
        .onSnapshot((snapshot) => {
            const ads = [];
            snapshot.forEach(doc => {
                ads.push({ 
                    id: doc.id, 
                    ...doc.data(),
                    isMyAd: multiplayerCurrentUser && doc.data().userId === multiplayerCurrentUser.uid
                });
            });
            console.log('Real-time trade ads update:', ads.length);
            callback(ads);
        }, (error) => {
            console.error('Trade ads listener error:', error);
        });
    
    return unsubscribe;
}

// ===================================
// PLAYER-TO-PLAYER TRADING
// ===================================

/**
 * Send a trade offer in response to an ad
 * @param {String} adId - The ad you're responding to
 * @param {Object} offerData - Your offer details
 * @returns {String} Offer ID
 */
async function sendTradeOffer(adId, offerData) {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return null;
    }
    
    try {
        // Get the original ad
        const adDoc = await db.collection('tradeAds').doc(adId).get();
        if (!adDoc.exists) {
            console.error('Ad not found');
            return null;
        }
        
        const ad = adDoc.data();
        
        // Can't trade with yourself
        if (ad.userId === multiplayerCurrentUser.uid) {
            console.error('Cannot trade with yourself');
            return null;
        }
        
        const offer = {
            adId: adId,
            adOwnerId: ad.userId,
            adOwnerUsername: ad.username,
            offeredBy: multiplayerCurrentUser.uid,
            offeredByUsername: offerData.username,
            offering: offerData.offering, // What you're giving
            message: offerData.message || '',
            status: 'pending', // pending, accepted, rejected, completed
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        const docRef = await db.collection('tradeOffers').add(offer);
        console.log('Trade offer sent!', docRef.id);
        return docRef.id;
    } catch (error) {
        console.error('Send trade offer failed:', error);
        return null;
    }
}

/**
 * Accept a trade offer (and execute the trade)
 * @param {String} offerId - Offer ID to accept
 * @param {Object} gameState - Current game state to verify inventory
 * @returns {Boolean} Success
 */
async function acceptTradeOffer(offerId, gameState) {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return false;
    }
    
    try {
        const offerDoc = await db.collection('tradeOffers').doc(offerId).get();
        if (!offerDoc.exists) {
            console.error('Offer not found');
            return false;
        }
        
        const offer = offerDoc.data();
        
        // Only ad owner can accept
        if (offer.adOwnerId !== multiplayerCurrentUser.uid) {
            console.error('Only ad owner can accept');
            return false;
        }
        
        // Get the original ad
        const adDoc = await db.collection('tradeAds').doc(offer.adId).get();
        if (!adDoc.exists) {
            console.error('Original ad not found');
            return false;
        }
        
        const ad = adDoc.data();
        
        // Verify both players have the items
        // (This would need to be done on the client side before calling)
        
        // Create trade record
        const trade = {
            player1: multiplayerCurrentUser.uid,
            player1Username: ad.username,
            player1Gave: ad.offering,
            player2: offer.offeredBy,
            player2Username: offer.offeredByUsername,
            player2Gave: offer.offering,
            adId: offer.adId,
            offerId: offerId,
            status: 'completed',
            completedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        await db.collection('playerTrades').add(trade);
        
        // Update offer status
        await db.collection('tradeOffers').doc(offerId).update({
            status: 'accepted',
            acceptedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        // Mark ad as completed
        await db.collection('tradeAds').doc(offer.adId).update({
            status: 'completed',
            completedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        console.log('Trade completed!');
        return true;
    } catch (error) {
        console.error('Accept trade offer failed:', error);
        return false;
    }
}

/**
 * Reject a trade offer
 * @param {String} offerId - Offer ID to reject
 * @returns {Boolean} Success
 */
async function rejectTradeOffer(offerId) {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return false;
    }
    
    try {
        const offerDoc = await db.collection('tradeOffers').doc(offerId).get();
        if (!offerDoc.exists) {
            console.error('Offer not found');
            return false;
        }
        
        const offer = offerDoc.data();
        
        // Only ad owner can reject
        if (offer.adOwnerId !== multiplayerCurrentUser.uid) {
            console.error('Only ad owner can reject');
            return false;
        }
        
        await db.collection('tradeOffers').doc(offerId).update({
            status: 'rejected',
            rejectedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        console.log('Trade offer rejected');
        return true;
    } catch (error) {
        console.error('Reject trade offer failed:', error);
        return false;
    }
}

/**
 * Load incoming trade offers for current user
 * @returns {Array} Array of offers
 */
async function loadMyTradeOffers() {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return [];
    }
    
    try {
        const snapshot = await db.collection('tradeOffers')
            .where('adOwnerId', '==', multiplayerCurrentUser.uid)
            .where('status', '==', 'pending')
            .orderBy('createdAt', 'desc')
            .get();
        
        const offers = [];
        snapshot.forEach(doc => {
            offers.push({ id: doc.id, ...doc.data() });
        });
        
        console.log('My trade offers loaded:', offers.length);
        return offers;
    } catch (error) {
        console.error('Load my trade offers failed:', error);
        return [];
    }
}

/**
 * Listen to real-time trade offers for current user
 * @param {Function} callback - Called when new offer arrives
 * @returns {Function} Unsubscribe function
 */
function listenToMyTradeOffers(callback) {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return () => {};
    }
    
    const unsubscribe = db.collection('tradeOffers')
        .where('adOwnerId', '==', multiplayerCurrentUser.uid)
        .where('status', '==', 'pending')
        .orderBy('createdAt', 'desc')
        .onSnapshot((snapshot) => {
            const offers = [];
            snapshot.forEach(doc => {
                offers.push({ id: doc.id, ...doc.data() });
            });
            console.log('Real-time trade offers update:', offers.length);
            callback(offers);
        }, (error) => {
            console.error('Trade offers listener error:', error);
        });
    
    return unsubscribe;
}

/**
 * Get player trade history (trades with other players)
 * @returns {Array} Array of completed trades
 */
async function getPlayerTradeHistory() {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return [];
    }
    
    try {
        const snapshot1 = await db.collection('playerTrades')
            .where('player1', '==', multiplayerCurrentUser.uid)
            .orderBy('completedAt', 'desc')
            .limit(20)
            .get();
        
        const snapshot2 = await db.collection('playerTrades')
            .where('player2', '==', multiplayerCurrentUser.uid)
            .orderBy('completedAt', 'desc')
            .limit(20)
            .get();
        
        const trades = [];
        snapshot1.forEach(doc => {
            trades.push({ id: doc.id, ...doc.data(), myRole: 'player1' });
        });
        snapshot2.forEach(doc => {
            trades.push({ id: doc.id, ...doc.data(), myRole: 'player2' });
        });
        
        // Sort by date
        trades.sort((a, b) => {
            const aTime = a.completedAt?.toMillis() || 0;
            const bTime = b.completedAt?.toMillis() || 0;
            return bTime - aTime;
        });
        
        console.log('Player trade history loaded:', trades.length);
        return trades;
    } catch (error) {
        console.error('Load player trade history failed:', error);
        return [];
    }
}

// ===================================
// NOTIFICATIONS
// ===================================

/**
 * Send a notification to a user
 * @param {String} userId - User to notify
 * @param {Object} notificationData - Notification details
 */
async function sendNotification(userId, notificationData) {
    if (!db) {
        console.error('DB not initialized');
        return false;
    }
    
    try {
        await db.collection('notifications').add({
            userId: userId,
            type: notificationData.type, // 'trade_offer', 'trade_accepted', etc.
            title: notificationData.title,
            message: notificationData.message,
            data: notificationData.data || {},
            read: false,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        console.log('Notification sent!');
        return true;
    } catch (error) {
        console.error('Send notification failed:', error);
        return false;
    }
}

/**
 * Listen to real-time notifications
 * @param {Function} callback - Called when new notification arrives
 * @returns {Function} Unsubscribe function
 */
function listenToNotifications(callback) {
    if (!multiplayerCurrentUser || !db) {
        console.error('Not authenticated or DB not initialized');
        return () => {};
    }
    
    const unsubscribe = db.collection('notifications')
        .where('userId', '==', multiplayerCurrentUser.uid)
        .where('read', '==', false)
        .orderBy('createdAt', 'desc')
        .onSnapshot((snapshot) => {
            const notifications = [];
            snapshot.forEach(doc => {
                notifications.push({ id: doc.id, ...doc.data() });
            });
            console.log('New notifications:', notifications.length);
            callback(notifications);
        }, (error) => {
            console.error('Notifications listener error:', error);
        });
    
    return unsubscribe;
}

/**
 * Mark notification as read
 * @param {String} notificationId - Notification ID
 */
async function markNotificationRead(notificationId) {
    if (!db) return;
    
    try {
        await db.collection('notifications').doc(notificationId).update({
            read: true,
            readAt: firebase.firestore.FieldValue.serverTimestamp()
        });
    } catch (error) {
        console.error('Mark notification read failed:', error);
    }
}

// ===================================
// EXPORT FUNCTIONS (for use in app.js)
// ===================================

// Make functions globally available
window.multiplayer = {
    // Leaderboard
    updateLeaderboard,
    loadLeaderboard,
    getMyRank,
    
    // Global Prices
    saveGlobalPrices,
    loadGlobalPrices,
    listenToGlobalPrices,
    
    // Trade Ads
    postTradeAd,
    loadTradeAds,
    deleteTradeAd,
    listenToTradeAds,
    
    // Player Trading
    sendTradeOffer,
    acceptTradeOffer,
    rejectTradeOffer,
    loadMyTradeOffers,
    listenToMyTradeOffers,
    getPlayerTradeHistory,
    
    // Notifications
    sendNotification,
    listenToNotifications,
    markNotificationRead
};

console.log('Multiplayer module loaded! Access via window.multiplayer');
    </script>

    <script type="text/babel">
    // Update currentUser reference for multiplayer
    auth.onAuthStateChanged((user) => {
        if (user) {
            multiplayerCurrentUser = user;
        }
    });
// ===================================
// TESTING VERSION - PRICES UPDATE EVERY 1 MINUTE!
// This is for TESTING - prices update fast so you can see it work
// ===================================

const { useState, useEffect } = React;

function isMarketOpen() {
    return true; // Always open for testing
    // const now = new Date();
    // const hour = now.getHours();
    // return hour >= 9 && hour < 21;
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}m ${secs}s`;
}

const AurababyMarket = () => {
    const babies = [
        { id: 1, name: 'Aurababy', image: 'https://i.ibb.co/Y4L448c1/aurababy.jpg' },
        { id: 2, name: 'KingDarren', image: 'https://i.ibb.co/1YGkQ5M4/kingdarren.jpg' },
        { id: 3, name: 'Daniel', image: 'https://i.ibb.co/RTwqxcck/daniel.jpg' },
        { id: 4, name: 'Manuel', image: 'https://i.ibb.co/JRr6BWjb/theonewhocknocks.jpg' },
        { id: 5, name: 'Grant', image: 'https://i.ibb.co/TqHnrtSp/grant.jpg' },
        { id: 6, name: 'Joony', image: 'https://i.ibb.co/fd9Kg05w/output.jpg' },
        { id: 7, name: 'Zoely', image: 'https://i.ibb.co/fVLDq186/zoely.png' },
        { id: 8, name: 'Lemmet', image: 'https://i.ibb.co/TBmZmYYh/newlemmet.jpg' },
        { id: 9, name: 'Kelly', image: 'https://i.ibb.co/Xk2DybZg/kelly.jpg' },
        { id: 10, name: 'Bryce', image: 'https://i.ibb.co/pvgyknnq/bryce.jpg' },
        { id: 11, name: 'FattieBaby', image: 'https://i.ibb.co/FkyMMCRv/fattiebaby.jpg' },
        { id: 12, name: 'Goonerbaby', image: 'https://i.ibb.co/b5DH8g26/goonerbaby.jpg' },
        { id: 13, name: 'Teros', image: 'https://i.ibb.co/Nd6v0WjN/teros.jpg' },
        { id: 14, name: 'Darkbaby', image: 'https://i.ibb.co/vCTDWs40/output-1.jpg' },
        { id: 15, name: 'GangstaBaby', image: 'https://i.ibb.co/TM91vD3z/Officalgangstababy.png' },
        { id: 16, name: 'Poorbaby', image: 'https://i.ibb.co/Nn9v6ZBw/poorbaby.jpg' },
        { id: 17, name: 'RichBaby', image: 'https://i.ibb.co/DDSNbypf/richbaby.jpg' },
        { id: 18, name: 'The Baby That Holds Aura', image: 'https://i.ibb.co/Kx8ZSGCB/The-Baby-That-Holds-Aura.jpg' },
        { id: 19, name: 'JollyBaby', image: 'https://i.ibb.co/bgp5mdQZ/jollybaby.png' },
        { id: 20, name: 'CupidBaby', image: 'https://i.ibb.co/1GbNb2PX/Untitled-4.png' },
        { id: 21, name: 'Judgment Baby', image: 'https://i.ibb.co/TqtxsJ52/judgment.jpg' },
        { id: 22, name: 'Justicen', image: 'https://i.ibb.co/dwkHnD65/Justicebaby.jpg' }
    ];

    const limitedItems = [
        { id: 'cat', name: 'Lucky Cat', emoji: 'ðŸ±', cost: 500, minValue: 300, maxValue: 900 },
        { id: 'dog', name: 'Diamond Dog', emoji: 'ðŸ¶', cost: 600, minValue: 400, maxValue: 1000 },
        { id: 'panda', name: 'Rare Panda', emoji: 'ðŸ¼', cost: 800, minValue: 500, maxValue: 1300 },
        { id: 'crown', name: 'Crown Aura', emoji: 'ðŸ‘‘', cost: 1000, minValue: 700, maxValue: 1700 },
        { id: 'fire', name: 'Fire Essence', emoji: 'ðŸ”¥', cost: 1500, minValue: 1000, maxValue: 2500 },
        { id: 'diamond', name: 'Diamond Baby', emoji: 'ðŸ’Ž', cost: 2500, minValue: 2000, maxValue: 4000 }
    ];

    const [money, setMoney] = useState(window.gameState?.money || 1000);
    const [username, setUsername] = useState(window.gameState?.username || 'Player');
    const [portfolio, setPortfolio] = useState(window.gameState?.portfolio || {});
    const [tradeHistory, setTradeHistory] = useState(window.gameState?.tradeHistory || []);
    
    const [prices, setPrices] = useState(() => {
        const p = {};
        babies.forEach(baby => { p[baby.id] = 150; });
        return p;
    });
    
    const [limitedValues, setLimitedValues] = useState(() => {
        const values = {};
        limitedItems.forEach(item => {
            values[item.id] = (item.minValue + item.maxValue) / 2;
        });
        return values;
    });
    
    const [marketOpen, setMarketOpen] = useState(true);
    const [timeUntilPriceUpdate, setTimeUntilPriceUpdate] = useState(60); // 1 minute for testing
    const [priceUpdateCount, setPriceUpdateCount] = useState(0);
    
    const [currentView, setCurrentView] = useState('market');
    const [selectedBaby, setSelectedBaby] = useState(null);

    const getPortfolioValue = () => {
        let total = 0;
        Object.keys(portfolio).forEach(id => {
            total += (portfolio[id] || 0) * (prices[id] || 0);
        });
        return Math.round(total * 100) / 100;
    };

    const buyBaby = (babyId, babyPrice) => {
        if (money >= babyPrice) {
            setMoney(prev => prev - babyPrice);
            setPortfolio(prev => ({ ...prev, [babyId]: (prev[babyId] || 0) + 1 }));
            
            const baby = babies.find(b => b.id === babyId);
            setTradeHistory(prev => [{
                id: Date.now(),
                type: 'BUY',
                babyName: baby.name,
                price: babyPrice,
                timestamp: new Date().toLocaleString()
            }, ...prev]);
        }
    };

    const sellBaby = (babyId, babyPrice) => {
        if (portfolio[babyId] && portfolio[babyId] > 0) {
            setMoney(prev => prev + babyPrice);
            setPortfolio(prev => ({ ...prev, [babyId]: prev[babyId] - 1 }));
            
            const baby = babies.find(b => b.id === babyId);
            setTradeHistory(prev => [{
                id: Date.now(),
                type: 'SELL',
                babyName: baby.name,
                price: babyPrice,
                timestamp: new Date().toLocaleString()
            }, ...prev]);
        }
    };

    // ===================================
    // PRICE UPDATE SYSTEM - TESTING VERSION (1 MINUTE)
    // ===================================
    
    useEffect(() => {
        console.log('ðŸš€ TESTING MODE ACTIVE: Prices update every 1 MINUTE!');
        
        // Countdown (updates every second)
        const countdown = setInterval(() => {
            setTimeUntilPriceUpdate(prev => {
                if (prev <= 1) {
                    return 60; // Reset to 1 minute
                }
                return prev - 1;
            });
        }, 1000);

        // Price update (every 1 minute for testing)
        const priceInterval = setInterval(() => {
            console.log('ðŸ”¥ 1 MINUTE PASSED! UPDATING ALL PRICES NOW!');
            
            setPrices(prevPrices => {
                const newPrices = { ...prevPrices };
                
                babies.forEach(baby => {
                    const changePercent = (Math.random() * 0.3 - 0.15); // -15% to +15%
                    const oldPrice = newPrices[baby.id];
                    let newPrice = oldPrice + (oldPrice * changePercent);
                    
                    if (newPrice < 10) newPrice = 10; // Minimum $10
                    if (newPrice > 1000) newPrice = 1000; // Maximum $1000
                    
                    newPrices[baby.id] = Math.round(newPrice * 100) / 100;
                    
                    const change = newPrice - oldPrice;
                    const changeSymbol = change >= 0 ? 'ðŸ“ˆ' : 'ðŸ“‰';
                    console.log(`${changeSymbol} ${baby.name}: $${oldPrice.toFixed(2)} â†’ $${newPrice.toFixed(2)} (${(changePercent * 100).toFixed(1)}%)`);
                });
                
                return newPrices;
            });
            
            // Increment update counter
            setPriceUpdateCount(prev => prev + 1);
            
            // Reset countdown
            setTimeUntilPriceUpdate(60);
            
            console.log('âœ… All prices updated!');
            
        }, 60000); // 60,000 ms = 1 minute

        return () => {
            clearInterval(countdown);
            clearInterval(priceInterval);
        };
    }, []); // Empty dependency array - only runs once

    // Income timer
    useEffect(() => {
        const timer = setInterval(() => {
            setMoney(prev => prev + 200);
        }, 90000); // Every 90 seconds
        return () => clearInterval(timer);
    }, []);

    return (
        <div style={{ display: 'flex' }}>
            <div className="sidebar">
                <h2>ðŸ’° Aurababy Market</h2>
                <div style={{ background: '#f39c12', color: 'white', padding: '10px', borderRadius: '5px', marginBottom: '15px', fontSize: '14px', fontWeight: 'bold' }}>
                    ðŸ§ª TESTING MODE<br/>
                    Prices update every 1 MIN!
                </div>
                
                <div className="sidebar-stats">
                    <div><strong>User:</strong><br/>{username}</div>
                    <div><strong>Cash:</strong><br/>${money.toLocaleString()}</div>
                    <div><strong>Portfolio:</strong><br/>${getPortfolioValue().toLocaleString()}</div>
                    <div><strong>Net Worth:</strong><br/>${(money + getPortfolioValue()).toLocaleString()}</div>
                    <div style={{ borderTop: '1px solid #7f8c8d', paddingTop: '10px', marginTop: '10px' }}>
                        <strong>Next Price Update:</strong><br/>
                        <span style={{ color: '#e74c3c', fontSize: '18px', fontWeight: 'bold' }}>{formatTime(timeUntilPriceUpdate)}</span>
                    </div>
                    <div style={{ fontSize: '12px', marginTop: '5px', color: '#27ae60' }}>
                        Updates completed: {priceUpdateCount}
                    </div>
                </div>

                <button onClick={() => setCurrentView('market')} 
                    className={`nav-button ${currentView === 'market' ? 'active' : ''}`}>
                    ðŸª Market
                </button>
                <button onClick={() => setCurrentView('portfolio')} 
                    className={`nav-button ${currentView === 'portfolio' ? 'active' : ''}`}>
                    ðŸ“Š Portfolio
                </button>
                <button onClick={() => setCurrentView('trades')} 
                    className={`nav-button ${currentView === 'trades' ? 'active' : ''}`}>
                    ðŸ“œ Trades ({tradeHistory.length})
                </button>
                
                <div className="sidebar-footer">
                    TESTING: 1 min updates<br/>
                    Watch prices change!
                </div>
            </div>

            <div className="main-content">
                {currentView === 'market' && (
                    <div>
                        <h1 className="view-title">ðŸª Baby Market - TESTING MODE</h1>
                        <div style={{ background: '#3498db', color: 'white', padding: '15px', borderRadius: '10px', marginBottom: '20px', textAlign: 'center' }}>
                            <strong>â° Next price update in: {formatTime(timeUntilPriceUpdate)}</strong><br/>
                            <small>Updates completed: {priceUpdateCount} | Prices change every 1 minute</small>
                        </div>
                        
                        <div className="card-grid">
                            {babies.map(baby => {
                                const price = prices[baby.id];
                                const owned = portfolio[baby.id] || 0;
                                
                                return (
                                    <div key={baby.id} className="card" onClick={() => setSelectedBaby(baby)}>
                                        <img src={baby.image} alt={baby.name} />
                                        <h3>{baby.name}</h3>
                                        <div className="card-price">${price.toFixed(2)}</div>
                                        {owned > 0 && <div className="card-info" style={{color:'blue'}}>You own: {owned}</div>}
                                        <button onClick={(e) => { e.stopPropagation(); buyBaby(baby.id, price); }}
                                            disabled={money < price} 
                                            className="card-button buy-button">
                                            BUY ${price.toFixed(2)}
                                        </button>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                )}

                {currentView === 'portfolio' && (
                    <div>
                        <h1 className="view-title">ðŸ“Š Your Portfolio</h1>
                        {Object.keys(portfolio).some(id => portfolio[id] > 0) ? (
                            <div className="card-grid">
                                {babies.map(baby => {
                                    const quantity = portfolio[baby.id] || 0;
                                    if (quantity === 0) return null;
                                    const currentPrice = prices[baby.id];
                                    
                                    return (
                                        <div key={baby.id} className="card">
                                            <img src={baby.image} alt={baby.name} />
                                            <h3>{baby.name}</h3>
                                            <div><strong>Quantity:</strong> {quantity}</div>
                                            <div className="card-price">${(quantity * currentPrice).toFixed(2)}</div>
                                            <button onClick={() => sellBaby(baby.id, currentPrice)} 
                                                className="card-button sell-button">
                                                SELL ${currentPrice.toFixed(2)}
                                            </button>
                                        </div>
                                    );
                                })}
                            </div>
                        ) : (
                            <p>No babies owned. Visit the Market!</p>
                        )}
                    </div>
                )}

                {currentView === 'trades' && (
                    <div>
                        <h1 className="view-title">ðŸ“œ Trade History</h1>
                        {tradeHistory.length > 0 ? (
                            <div>
                                {tradeHistory.slice(0, 20).map(trade => (
                                    <div key={trade.id} className={`trade-item ${trade.type === 'SELL' ? 'trade-sell' : 'trade-buy'}`}>
                                        <div className="trade-info">
                                            <strong>{trade.type}</strong>: {trade.babyName}
                                            <div style={{ fontSize: '14px', color: '#666' }}>{trade.timestamp}</div>
                                        </div>
                                        <div className="trade-price">
                                            ${trade.price.toLocaleString()}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <p>No trades yet. Start buying and selling!</p>
                        )}
                    </div>
                )}
            </div>

            {selectedBaby && (
                <div onClick={() => setSelectedBaby(null)} className="modal-overlay">
                    <div onClick={e => e.stopPropagation()} className="modal">
                        <img src={selectedBaby.image} alt={selectedBaby.name} 
                            style={{ width: '100%', maxHeight: '300px', objectFit: 'cover', borderRadius: '10px' }} />
                        <h2 className="mt-20">{selectedBaby.name}</h2>
                        <div className="card-price">${prices[selectedBaby.id].toFixed(2)}</div>
                        <div className="mb-20">You own: {portfolio[selectedBaby.id] || 0}</div>
                        <div className="modal-buttons">
                            <button onClick={() => buyBaby(selectedBaby.id, prices[selectedBaby.id])}
                                disabled={money < prices[selectedBaby.id]} 
                                className={`modal-button ${money >= prices[selectedBaby.id] ? 'modal-button-primary' : 'modal-button-cancel'}`}>
                                BUY ${prices[selectedBaby.id].toFixed(2)}
                            </button>
                            {portfolio[selectedBaby.id] > 0 && (
                                <button onClick={() => sellBaby(selectedBaby.id, prices[selectedBaby.id])} 
                                    className="modal-button modal-button-secondary">
                                    SELL ${prices[selectedBaby.id].toFixed(2)}
                                </button>
                            )}
                        </div>
                        <button onClick={() => setSelectedBaby(null)} 
                            className="modal-button modal-button-cancel mt-20" style={{ width: '100%' }}>
                            Close
                        </button>
                    </div>
                </div>
            )}
        </div>
    );
};

ReactDOM.render(<AurababyMarket />, document.getElementById('root'));
    </script>
</body>
</html>
